section 4 

lesson 19 -> 
 
the data need to set in .env file this is file save the data will change from development mode to production mode -> 
1- port number -> this is maybe change in production mode 

to acess port -> from env file need
1- to install dotenv package
2- used dotenv.config({path:"config.env"})
3- import from process -> process.env.portname 

-------------------------------------------

lesson 20 -> 

http logger 

this is middleware used to logs information about incoming http request and http response 

to make logger need module called -> morgan

what is middleware ? -> mehtod between request and respose can make in it somthings and return response about those things

so morgan is middleware & it's usefull for development mode 

-------------------------------------------

lesson 21 -> 

mongodb atlas 

1- can access your machine ip and this is only will worked with this database 
2- can set access from anywhere and will make any device access it 

cluster is can called it big container have your databases

-------------------------------------------

lesson 23 -> 

some infromation about mongodb

you have an collection on databases this similarly table on sql databases

collection -> table 

document in collection in mongo -> row in sql

field in document in mongo -> column

-------------------------------------------

lesson 25 -> 

project folders structure 

- we used folders structure to make important concpet -> separation of concerns 
- fouces the instractor worked with service folder we worked with controller 


-------------------------------------------

lesson 26 -> 

express middleware explanation

// anything in express is middleware

// in your request response cycle you fire middlewares and every middleware execute for move to another one 
// so you have two things (middleware stack , request response cycle)

// ----------------------------------------------------------

// summary section 4 -> 

// we create those -> 
1- creating server using express and using nodemon to watch changes
2- Environment variables and stop track files in version controle (git) using gitignore
3- logging requests using morgan 
4- overview about mongodb, installing and connect to our app and mongo compass
5- make our first operation in our mongodb
6- project folders structure

// ----------------------------------------------------------

// lesson 28 -> 
category schema and models -> 

this is talk about schema for category models and (the types and constrains for every schema filed will get it from buisniess analysis)
ACL -> access controle layer
slug -> this is used to replace any whitespace with (dash -) ex: category name (a and b) url will be (shopping.com/a-and-b)

timestamps -> this is used to create in database two fileds (created at and updated at)

// lesson 30 -> 

// using async await syntex 

- to handling async errors need to download and used package -> express-async-handler

// lesson 32 ->

// categories pagination

- in production mode or any case data will be big so need to send this data but not only in one time -> this is pagination

- every page have an some of data 

- steps 

1- need to set number of page -> page = 1
2- need to set of limit for the data will return from database -> limit = 5
3- need to set the length will skip it  -> skip = (page - 1) * limit 
 ---------------------------------------------------------------------------------

- summary section 5 -> 

1- we create (CRUD operation) -> 
    1- create category
    2- read category
    3- update category
    4- delete category

2- we make an pagination -> divide the data into pages 

3- create my requests on postman and orgnaized all of those 
 ------------------------------------------------------------------------

section 6 

lesson 39 -> 

create error -> used Error constractor and send the message inside it 

lesson 44 -> 

Handle Errors -> global error we create it in older lessons solve any error on (express only) 
- so if you need to create an handler for rejected promises or any Error will happend on anything else 

lesson 45 -> 

validation layer benifites -> 

- the pipline Error run without validation layer 
1- make request
2- go to route
3- go to controllers 
4- go to models for database
5- databse return the error 

- the pipline Error run using validation layer 
1- make request
2- go to route 
3- go to validation 
4- if the validation true will go to controllers && but if validation flase or not valid return error
5- go to model or database

- will apply this validation middleware using -> Express validator 

lesson 46 -> 

implement validation layer -> 
- this is pipline for create validation layer or validation schema

1- rules -> import what you need to create validate about it -> data send on body, data send on params ,....
2- create middleware -> create middleware for validate the input if return false need to return response else will go to the next in this case will be controller
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

section 6 summary -> 

we worked with error handler in any type ->
1- express error handler used -> global middleware
2- error outside express used -> unhnadled rejections
3- validation layer benefits used -> express-validator
4- handled in development and in production env used -> development ("start:dev": "nodemon .") , production ("start:prod": "set NODE_ENV=production && node app.js")
5- handled unfound route
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
section 7 -> 

lesson 2 sub category schema & model -> 

we create the schema for sub category but the note on this lesson is we (wrap , sub category و main category هتربط بين ال  ) sub category with main category -> 
this is connection if you used sql database will called it forgin key -> category: {
            type: mongoose.Schema.ObjectId,
            ref: "category model",
            required: [true, "SubCategory must be belong to parent category"]
}

lesson 3 use ESLint with some Airbnb configurations -> 

1- setup Eslint package -> used to check if found error or not in your code 
- this is .eslintrc.json file is static file you will take it on any project & import -> (npm i -D eslint eslint-config-airbnb eslint-config-prettier eslint-plugin-import eslint-plugin-jsx-a11y eslint-plugin-node eslint-plugin-prettier eslint-plugin-react prettier)

lesson 7 populate category name lesson -> 

this is lesson talk about if you need to return main category for SubCategory in show all SubCategory

fouces ->
1- this is mean you make two queries on database -> this is load on database
2- if you don't need it on your main idea don't create it 

ex: this is way for create
.populate({paht:'filed name in database',select:'filed need to show'})

 .populate({
            path: "category model",
            select: "-_id name"

 })

 -_id -> this is used to remove _id in populate

lesson 8 get all subcategories from specific category -> 

// note :
// nested route -> any parent have a child the route for it will write used this way -> /api/v1/parent/:parentId/child 
// ex: /api/v1/categories/:categoriesId/subcategories

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
section 8 ->

lesson 71 ->

this is lesson talk about filtration data about the user request ->

1- solve -> used it on mongoose query
ex: databaseModel.find({_id:req.query.id,name:req.query.name})
ex2: you can send query without destructing -> databaseModel.find(req.query)

solve 2 for ex2 -> need to remove some items from queries send to you
ex2:
1- first destruct the object -> const queryAfterDestruct = {...req.query}
2- set the excludes items -> const excludes =['page','limit','sort',  'fields']
3- remove from queryAfterDestruct the item need to excludes it -> excludes.forEach((item) => delete queryAfterDestruct[item])


2- solve -> used where and equals
ex:databaseModel.where("filed name").equals("value") -> databaseModel.where("name").equals("kerlos")

lesson 84 ->
use Mongoose query middleware to populate category in product

you have a more than four types on mongoose query ->

(document middleware), (model middleware), (aggregate middleware), and (query middleware).

query middleware -> used to make query ->
doc description: Query middleware is supported for the following Query functions. Query middleware executes when you call exec() or then() on a Query object, or await on a Query object. In query middleware functions, this refers to the query.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
section 9 ->
upload image and image processing

lesson 86->

can use a lot of solutions to make it like ->
1- multer
2- cloud nary
3- anything used on AWS

we will work on -> Multer
------------------------------------------------
lesson 87 ->
upload single image using multer

if you need to find anything about this package will see it on GitHub repo

steps to upload single image ->
1- define variable for multer
2- define variable will take instance from multer variable and will define parameter on this multer variable called (dest) will take the path need to set the image on it
3- you will write it middleware on the route and will used second variable.single('field name')
4- this is middleware will return on request file -> this file is image and write this middleware after send this file on your route

NOTE: to extract data from json object used -> JSON.stringify(objectName)
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
problems we fouces it on this project =>
p for problem , s for solve
1 p - the databse created with name (test) this is created because we don't entered the datbase name 
1 s - write after .net/ datbase name -> .net/datbase_name 
----
2 p - when need to get user by id fouce on the id length because this is maybe will make bug in app
2 s - used mongoose.validate
----
3 p - in section error handler we fouces a problem in (statusCode) we create the parameter in constractor (parenthers) have same name with the constractor (variable) 
3 s - change the variable name or constractor parameter name  


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
- Global Note

1- when you worked on any project fouces on create the main function and after this fouces on create refactoring for this code 

2- fouces when upload the data in github branch need to used flage -> force 